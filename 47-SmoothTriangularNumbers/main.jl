#=
Approach:
Let S(p) be the sum of all n, so that T(n) is p-smooth. Notice that T(n) = n * (n + 1) / 2.
Thus T(n) is p-smooth if n and n+1 are p-smooth, for p > 2.

Using Stormer's theorem with Lehmer's method we can solve this problem.

---------------------------------------------------------------------------------------------------

                        PROOF OF LEHMER'S METHOD FOR STORMER'S PROBLEM

Definition: Unit of a ring
--------------------------

A unit of a ring R is an element a such that there is an element b where a * b = 1.

Definition: Norm of Z[sqrt(D)]
------------------------------

The norm N in the ring Z[sqrt(D)] is a multiplicative function defined as:

N(x + sqrt(D) * y) = (x + sqrt(D) * y) * (x - sqrt(D) * y)

Clearly, solutions to Pell's equation have norm 1, and are therefore units of this ring.

Properties of the Lucas Function Un
-----------------------------------

Let x^2 - D * y^2 = 1 be Pell's equation. Let (xn, yn) be the nth solution to this equation. Then:

1. xn + sign(n) * sqrt(D) * yn = (x1 + sqrt(D) * y1)^n, where x1 + sqrt(D) * y1 is the smallest solution
to the problem.

Proof:
------

First let us prove the case for n >= 0.

Clearly, x1 + sqrt(D) * y1 is an unit of the ring Z[sqrt(D)]. Notice that because the norm is multiplicative
then N((x1 + sqrt(D) * y1)^n) = N(x1 + sqrt(D) * y1)^n = 1^n = 1. Thus (x1 + sqrt(D) * y1)^n is a solution
to Pell's equation. Let (x1 + sqrt(D) * y1)^n = xn' + sqrt(D) * yn'. We will show that all solutions are of
this form. Suppose xn + sqrt(D) * yn is not of the form (x1 + sqrt(D) * y1)^n. Let m be the largest integer
such that xn + sqrt(D) * yn > (x1 + sqrt(D) * y1)^m. Notice that (x1 + sqrt(D) * y1)^-1 = x1 - sqrt(D) * y1.
Let a = (xn + sqrt(D) * yn) * (x1 + sqrt(D) * y1)^-m = (xn + sqrt(D) * yn) * (x1 - sqrt(D) * y1)^m. Let
a = xn~ + sqrt(D) * yn~. Notice that a has a norm of 1, by the multiplicativity of N, thus it is a solution
to Pell's equation. Also, it is clear that a > 1. Therefore xn~ and yn~ are positive. Also:

xn + sqrt(D) * yn < (x1 + sqrt(D) * y1)^(m + 1)
a < x1 + sqrt(D) * y1

But this contradicts the fact that x1 + sqrt(D) * y1 is the smallest solution, which must exists as all solutions
are convergents of the sqrt(D) and can therefore be ordered.

Finally notice that:

xn - sqrt(D) * yn = (xn - sqrt(D) * yn) * (xn + sqrt(D) * yn) / (xn + sqrt(D) * yn)
                  = (xn^2 - D * yn^2) / (xn + sqrt(D) * yn)
                  = 1 / (xn + sqrt(D) * yn)
                  = 1 / (x1 + sqrt(D) * y1)^n
                  = (x1 + sqrt(D) * y1)^-n

-------------------------------------------------------------------------------------------------------------

2. Let a = x1 + sqrt(D) * y1, b = x1 - sqrt(D) * y1, so that a + b = 2 * x1, a * b = 1, a - b = 2 * sqrt(D) * y1,
and 2 * xn = a^n + b^n, 2 * sqrt(D) * yn = a^n - b^n. We also introduce Un = yn / y1 = (a^n - b^n) / (a - b).
Also define Q to be the set of numbers generated by multiplying the primes q1, q2, ... , qt, with q1 < q2 < ... < qt
and let M = max(3, (qt + 1) / 2). Then:

a. x2n = 2 * xn^2 - 1
b. U2n = 2 * xn * Un
c. xm+-n = xm * xn +- D * ym * yn
d. Um+-n = xn * Um +- xm * Un
e. Un = sum(i >= 0) (n choose 2 * i + 1) * D^i * y1^(2 * i) * x1^(n - 1 - 2 * i)
f. xn = sum(i >= 0) (n choose 2 * i) * D^i * y1^(2 * i) * x1^(n - 2 * i)
g. Umn = sum(i >= 0) (n choose 2 * i + 1) * D^i * Um^(2 * i + 1) * y1^(2 * i) * xm^(n - 1 - 2 * i)

Proof:
------

a. x2n + sqrt(D) * y2n = (x1 + sqrt(D) * y1)^(2 * n)
                       = ((x1 + sqrt(D) * y1)^n)^2
                       = (xn + sqrt(D) * yn)^2
                       = xn^2 + sqrt(D) * 2 * xn * yn + D * yn^2

Thus, x2n = xn^2 + D * yn^2 = 2 * xn^2 + D * yn^2 - xn^2 = 2 * xn^2 - 1.

b. Due to the previous proof y2n = 2 * xn * yn, thus: 2 * xn = y2n / yn = (y2n / y1) / (yn / y1) = U2n / Un,
and therefore U2n = 2 * xn * Un.

c. Without loss of generality, assume all signs are positive:

xm+n + sqrt(D) * ym+n = (x1 + sqrt(D) * y1)^(m + n)
                      = (xm + sqrt(D) * ym) * (xn + sqrt(D) * yn)
                      = xm * xn + sqrt(D) * ym * xn + sqrt(D) * yn * xm + D * ym * yn

Thus: xm+n = xm * xn +- D * ym * yn.

d. By the previous proof ym+n = xn * ym + xm * yn. Thus:

ym+n / y1 = xn * ym / y1 + xm * yn / y1
Um+n = xn * Um + xm * Un

e. xn + sqrt(D) * yn = (x1 + sqrt(D) * y1)^n
                     = sum(k = 0, n) (n choose k) sqrt(D)^k * y1^k * x1^(n - k)

Thus:

yn = sum(k >= 0) (n choose 2 * k + 1) D^k * y1^(2 * k + 1) * x1^(n - 2 * k - 1)
yn / y1 = sum(k >= 0) (n choose 2 * k + 1) D^k * y1^(2 * k) * x1^(n - 2 * k - 1)
Un = sum(k >= 0) (n choose 2 * k + 1) D^k * y1^(2 * k) * x1^(n - 2 * k - 1)

f. By the previous proof:

xn = sum(k >= 0) (n choose 2 * k) D^k * y1^(2 * k) * x1^(n - 2 * k)

g. xmn + sqrt(D) * ymn = (x1 + sqrt(D) * y1)^(m * n)
                       = ((x1 + sqrt(D) * y1)^m)^n
                       = (xm + sqrt(D) * ym)^n
                       = sum(k = 0, n) (n choose k) sqrt(D)^k * ym^k * xm^(n - k)

Thus:

ymn = sum(k >= 0) (n choose 2 * k + 1) D^k * ym^(2 * k + 1) * xm^(n - 2 * k - 1)
ymn / y1 = sum(k >= 0) (n choose 2 * k + 1) D^k * ym^(2 * k + 1s) * xm^(n - 2 * k - 1) / y1
Umn = sum(k >= 0) (n choose 2 * k + 1) D^k * ym^(2 * k + 1) * xm^(n - 2 * k - 1) / y1
Umn = sum(k >= 0) (n choose 2 * k + 1) D^k * ym^(2 * k + 1) / y1^(2 * k + 1) * y1^(2 * k + 1) * xm^(n - 2 * k - 1) / y1
Umn = sum(k >= 0) (n choose 2 * k + 1) D^k * ym^(2 * k + 1) / y1^(2 * k + 1) * y1^(2 * k) * xm^(n - 2 * k - 1)
Umn = sum(k >= 0) (n choose 2 * k + 1) D^k * Um^(2 * k + 1) * y1^(2 * k) * xm^(n - 2 * k - 1)

-------------------------------------------------------------------------------------------------------------

Definition: Rank of Apparition
------------------------------

Let p >= 2 be a prime, and let w(p) be the least positive j for which Uj is divisible by p.

-------------------------------------------------------------------------------------------------------------

Lemma 1 (Law of Apparition)
---------------------------

Let p >= 2 be a prime number. Then:

1. w(2) = 2.
2. w(p) = p if p divides D * y1.
3. For any other prime p, w(p) divides (p - e) / 2, where e = D^((p - 1) / 2) (mod p).

Proof:
------

1. U1 = 1. U2 = 2 * x1 * U1 = 2 * x1 (using b). Thus 2 | U2.

2. If p divides D * y1, then (using e):

Un = sum(i >= 0) (n choose 2 * i + 1) * D^i * y1^(2 * i) * x1^(n - 1 - 2 * i) (mod p)

when i > 0, the term is a factor of D * y1, therefore it equals 0 mod p. Thus i = 0. Using this:

Un = (n choose 1) * x1^(n - 1) = n * x1^(n - 1) (mod p)

Also, because x1^2 - D * y1^2 = 1, then x1^2 = 1 (mod p). Because Zp has no zero divisors, this
equation has only two solutions x1 = -1 and x1 = 1. Thus p does not divide x1 and therefore can only
divide n. Thus w(p) = p.

3. If p > 2 and p does not divide D * y1, then (using e):

Up = sum(i >= 0) (p choose 2 * i + 1) * D^i * y1^(2 * i) * x1^(p - 1 - 2 * i) (mod p)

Note that (p choose k) = p! / (k! * (p - k)!). Clearly, p | p!, therefore p | (p choose k),
as p cannot divide k! nor (p - k)!, except when k = p or p - k = p (k = 0). Thus 2 * i + 1 = p,
as 2 * i + 1 > 0. Therefore:

Up = D^((p - 1) / 2) * y1^(p - 1) = D^((p - 1) / 2) = e (mod p)

Similarly, using f, we get:

xp = sum(i >= 0) (p choose 2 * i) * D^i * y1^(2 * i) * x1^(p - 2 * i) (mod p)
xp = x1^p = x1 (mod p)

Notice that p does not divide D * y1, and thus it can't divide D. Therefore:

e = D^((p - 1) / 2) = +- 1 (mod p).

Using d, if e = 1 (mod p):

Up-e = xe * Up - xp * Ue (mod p)
     = x1 * e - x1 * U1 (mod p)
     = x1 * (e - 1) (mod p)
     = 0 (mod p)

If e = -1 (mod p), then:

Up-e = Up+1 = x1 * Up + xp * U1 (mod p)
            = x1 * e + x1 (mod p)
            = x1 * (e + 1) (mod p)
            = 0 (mod p)

And using c, if e = 1 (mod p):

xp-e = xp * xe - D * yp * ye (mod p)
     = xp * x1 - D * yp * y1 (mod p)
     = x1^2 - D * yp * y1 (mod p)
     = x1^2 - D * (yp / y1) * y1^2 (mod p)
     = x1^2 - D * Up * y1^2 (mod p)
     = x1^2 - D * e * y1^2 (mod p)
     = x1^2 - D * y1^2 (mod p)
     = 1 (mod p)

Similarly, if e = -1 (mod p):

xp-e = xp+1 (mod p)
     = xp * x1 + D * yp * y1 (mod p)
     = x1^2 + D * yp * y1 (mod p)
     = x1^2 + D * (yp / y1) * y1^2 (mod p)
     = x1^2 + D * Up * y1^2 (mod p)
     = x1^2 + D * e * y1^2 (mod p)
     = x1^2 - D * y1^2 (mod p)
     = 1 (mod p)

Now, using a:

xp-e = 2 * x((p - e) / 2)^2 - 1

Thus, because xp-e = 1 (mod p):

2 * x((p - e) / 2)^2 - 1 = 1 (mod p)
2 * x((p - e) / 2)^2 - 2 = 0 (mod p)
2 * (x((p - e) / 2)^2 - 1) = 0 (mod p)
2 * (x((p - e) / 2) - 1) * (x((p - e) / 2) + 1) = 0 (mod p)

Thus p does not divide x((p - e) / 2). But using b:

Up-e = 2 * x((p - e) / 2) * U((p - e) / 2)

Because Up-e = 0 (mod p), p must divide U((p - e) / 2). Thus w(p) is at most (p - e) / 2.

Let Un be such that p | Un. Let v = n - w(p). Thus:

Un = Uw(p)+v = xv * Uw(p) + xw(p) * Uv

Notice that Un = xw(p) * Uv (mod p), as p | Uw(p). If v >= w(p), we can keep subtracting w(p) from it,
and cancelling terms until v < w(p). In the case v < w(p) then either p | xw(p) or p | Uv. Notice that
if we let p | xw(p) then Uw(p)-1 = x1 * Uw(p) - xw(p) * U1 = 0 (mod p), as p | Uw(p), which is a
contradiction. Thus p cannot divide xw(p) and must divide Uv. But v being smaller than w(p) and positive
contradicts the definition of w(p). Thus v = 0. That is, n is evenly divisible by w(p).

In particular, w(p) divides (p - e) / 2.

-------------------------------------------------------------------------------------------------------------

Lemma 2
-------

Let p > 3 be a prime dividing D * y1. Then Up = p (mod p^2)

Proof:
------

Using e:

Up = sum(i >= 0) (p choose 2 * i + 1) * D^i * y1^(2 * i) * x1^(p - 1 - 2 * i) (mod D^2 * y1^2)
   = (p choose 1) * x1^(p - 1) + (p choose 3) * D * y1^2 * x1^(p - 3) (mod D^2 * y1^2)
   = p * x1^(p - 1) + (p choose 3) * D * y1^2 * x1^(p - 3) (mod D^2 * y1^2)

Since p | D * y1 and p | (p choose 3), then Up = p * x1^(p - 1) (mod p^2). Since x1^(p - 1) = 1 (mod p), then
x1^(p - 1) = (1 + k * p) (mod p^2), for some k. Thus Up = p * x1^(p - 1) = p * (1 + k * p) = p (mod p^2).

-------------------------------------------------------------------------------------------------------------

Lemma 3 (Law of Repetition)
---------------------------

Let l >= 0, and let k be an integer not divisible by the prime p. Let p^a, a > 0, be the highest power of p
dividing Um. Then the highest power of p dividing U(k * m * p^l) is p^(a + l).

Proof:
------

Let l = 0. Then, using g:

Ukm = sum(i >= 0) (k choose 2 * i + 1) * D^i * Um^(2 * i + 1) * y1^(2 * i) * xm^(k - 1 - 2 * i) (mod Um^3)
    = k * Um * xm^(k - 1) (mod Um^3)

Therefore Ukm = k * Um * xm^(k - 1) + r * Um^3, for some integer r. Therefore p^a clearly divides Ukm. To
see that no higher power of p divides Ukm notice that by hypothesis p does not divide k. Also, because
p | Um = ym / y1, then p | ym. Therefore:

xm^2 - D * ym^2 = 1 (mod p)
xm^2 = 1 (mod p)

Therefore p does not divide xm, and therefore the largest power of p that divides Ukm must be p^a.

Let l = 1. Then, using g:

Ukmp = sum(i >= 0) (k * p choose 2 * i + 1) * D^i * Um^(2 * i + 1) * y1^(2 * i) * xm^(k * p - 1 - 2 * i) (mod Um^3)
    = k * p * Um * xm^(k * p - 1) (mod Um^3)

Using a similar argument to the one before we can prove that the largest power of p that divides Ukmp must
be p^(a + 1).

Let l > 1. Assume that the statement is true for 0, 1, 2, ... , l - 1. Then the highest power of p dividing
U(k * m * p^(l - 1)) is p^(a + l - 1). Then, using g:

U(k * m * p^l) = sum(i >= 0) (p choose 2 * i + 1) * D^i * U(k * m * p^(l - 1))^(2 * i + 1) * y1^(2 * i) * x(k * m * p^(l - 1))^(p - 1 - 2 * i) (mod U(k * m * p^(l - 1))^3)
    = p * U(k * m * p^(l - 1)) * x(k * m * p^(l - 1))^(p - 1) (mod U(k * m * p^(l - 1))^3)
    = p * U(k * m * p^(l - 1)) * x(k * m * p^(l - 1))^(p - 1) (mod U(k * m * p^(l - 1))^3)

The highest power of p that divides U(k * m * p^(l - 1)) is p^(a + l - 1). As p does not divide x(k * m * p^(l - 1))
the highest power of p that can divide U(k * m * p^l) is p^(a + l).

-------------------------------------------------------------------------------------------------------------

Definition
----------

Let Un = (a^n - b^n) / (a - b). Then we will define Gn to be a subset of factors of Un, in terms of a and b.
Specifically:

Gn = prod(h = 1, n - 1, h coprime to n) [ a - b * e^(2 * pi * i * h / n) ]

Also, a prime factor of Gn which divides n is called intrinsic. Otherwise it is called extrinsic.

Corollaries:
------------

1. Gn is an integer. To see this FIXME: prove this

2. Un = prod(s | n) Gs. To see this: FIXME: prove this

-------------------------------------------------------------------------------------------------------------

FIXME: missing proof for Stormer's theorem.
---------------------------------------------------------------------------------------------------

Finally, from OEIS A117581, the largest p-smooth number for p = 47 is 1109496723125. Thus,
we can stop searching when we go over this value.

Sources:
https://en.wikipedia.org/wiki/St%C3%B8rmer%27s_theorem
https://projecteuclid.org/download/pdf_1/euclid.ijm/1256067456

=#

using Printf

function is_smooth(primes, x)
    xv = x
    for p in primes
        while xv % p == 0
            xv = fld(xv, p)
        end
    end
    return xv == 1
end

function solve(primes, v, s)
    r = 0
    n = 0
    d = 2 * v
    ul = BigInt(2)^65 + 1 # (p - 1) / 2 < 2^64
    # Solve Pell's equation
    a0 = BigInt(floor(sqrt(d)))
    mk = BigInt(0)
    dk = BigInt(1)
    ak = a0
    p_prev = BigInt(1)
    q_prev = BigInt(0)
    p = ak
    q = BigInt(1)
    while n < s && p < ul
        mk = ak * dk - mk
        dk = div(d - mk^2, dk)
        ak = div(a0 + mk, dk)
        p_temp = p
        q_temp = q
        p = ak * p + p_prev
        q = ak * q + q_prev
        p_prev = p_temp
        q_prev = q_temp
        if p^2 - d * q^2 == 1
            # Generate result
            x1 = fld(p - 1, 2)
            x2 = fld(p + 1, 2)
            if is_smooth(primes, x1) && is_smooth(primes, x2)
                r += x1
            end
            n += 1
        end
    end
    return r
end

function search(result, primes, s, i, q)
    if i > length(primes)
        if q != 2
            result += solve(primes, q, s)
        end
        return result
    end
    result = search(result, primes, s, i + 1, q)
    result = search(result, primes, s, i + 1, q * primes[i])
    return result
end

start = time()
result = 0

p = 47

primes = []
slots = [true for _ in 1:p]
slots[1] = false
for k in 2:p
    global slots
    if slots[k]
        push!(primes, k)
        for t in (2 * k):k:p
            slots[t] = false
        end
    end
end

pmax = last(primes)
s = max(3, fld(pmax + 1, 2))
result = search(result, primes, s, 1, 1)

println(result)

elapsed = time() - start
@printf("Took: %.4f secs\n", elapsed)
